// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: onnx.proto3
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.

// Copyright (c) ONNX Project Contributors.
// Licensed under the MIT license.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Versioning
///
/// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
///
/// To be compatible with both proto2 and proto3, we will use a version number
/// that is not defined by the default value but an explicit enum number.
enum Onnx_Version: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// proto3 requires the first enum value to be zero.
  /// We add this just to appease the compiler.
  case startVersion // = 0

  /// The version field is always serialized and we will use it to store the
  /// version that the  graph is generated from. This helps us set up version
  /// control. 
  /// For the IR, we are using simple numbers starting with with 0x00000001, 
  /// which was the version we published on Oct 10, 2017.
  case irVersion20171010 // = 1

  /// IR_VERSION 2 published on Oct 30, 2017
  /// - Added type discriminator to AttributeProto to support proto3 users
  case irVersion20171030 // = 2

  /// IR VERSION 3 published on Nov 3, 2017
  /// - For operator versioning:
  ///    - Added new message OperatorSetIdProto
  ///    - Added opset_import in ModelProto
  /// - For vendor extensions, added domain in NodeProto
  case irVersion2017113 // = 3

  /// IR VERSION 4 published on Jan 22, 2019
  /// - Relax constraint that initializers should be a subset of graph inputs
  /// - Add type BFLOAT16
  case irVersion2019122 // = 4

  /// IR VERSION 5 published on March 18, 2019
  /// - Add message TensorAnnotation.
  /// - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
  case irVersion // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .startVersion
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startVersion
    case 1: self = .irVersion20171010
    case 2: self = .irVersion20171030
    case 3: self = .irVersion2017113
    case 4: self = .irVersion2019122
    case 5: self = .irVersion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .startVersion: return 0
    case .irVersion20171010: return 1
    case .irVersion20171030: return 2
    case .irVersion2017113: return 3
    case .irVersion2019122: return 4
    case .irVersion: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Onnx_Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_Version] = [
    .startVersion,
    .irVersion20171010,
    .irVersion20171030,
    .irVersion2017113,
    .irVersion2019122,
    .irVersion,
  ]
}

#endif  // swift(>=4.2)

/// Attributes
///
/// A named attribute containing either singular float, integer, string, graph,
/// and tensor values, or repeated float, integer, string, graph, and tensor values.
/// An AttributeProto MUST contain the name field, and *only one* of the
/// following content fields, effectively enforcing a C/C++ union equivalent.
struct Onnx_AttributeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name field MUST be present for this version of the IR.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
  /// In this case, this AttributeProto does not contain data, and it's a reference of attribute
  /// in parent scope.
  /// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
  var refAttrName: String {
    get {return _storage._refAttrName}
    set {_uniqueStorage()._refAttrName = newValue}
  }

  /// A human-readable documentation for this attribute. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  /// The type field MUST be present for this version of the IR.
  /// For 0.0.1 versions of the IR, this field was not defined, and
  /// implementations needed to use has_field hueristics to determine
  /// which value field was in use.  For IR_VERSION 0.0.2 or later, this
  /// field MUST be set and match the f|i|s|t|... field in use.  This
  /// change was made to accomodate proto3 implementations.
  var type: Onnx_AttributeProto.AttributeType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Exactly ONE of the following fields must be present for this version of the IR
  var f: Float {
    get {return _storage._f}
    set {_uniqueStorage()._f = newValue}
  }

  /// int
  var i: Int64 {
    get {return _storage._i}
    set {_uniqueStorage()._i = newValue}
  }

  /// UTF-8 string
  var s: Data {
    get {return _storage._s}
    set {_uniqueStorage()._s = newValue}
  }

  /// tensor value
  var t: Onnx_TensorProto {
    get {return _storage._t ?? Onnx_TensorProto()}
    set {_uniqueStorage()._t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return _storage._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {_uniqueStorage()._t = nil}

  /// graph
  var g: Onnx_GraphProto {
    get {return _storage._g ?? Onnx_GraphProto()}
    set {_uniqueStorage()._g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  var hasG: Bool {return _storage._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  mutating func clearG() {_uniqueStorage()._g = nil}

  /// list of floats
  var floats: [Float] {
    get {return _storage._floats}
    set {_uniqueStorage()._floats = newValue}
  }

  /// list of ints
  var ints: [Int64] {
    get {return _storage._ints}
    set {_uniqueStorage()._ints = newValue}
  }

  /// list of UTF-8 strings
  var strings: [Data] {
    get {return _storage._strings}
    set {_uniqueStorage()._strings = newValue}
  }

  /// list of tensors
  var tensors: [Onnx_TensorProto] {
    get {return _storage._tensors}
    set {_uniqueStorage()._tensors = newValue}
  }

  /// list of graph
  var graphs: [Onnx_GraphProto] {
    get {return _storage._graphs}
    set {_uniqueStorage()._graphs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Note: this enum is structurally identical to the OpSchema::AttrType
  /// enum defined in schema.h.  If you rev one, you likely need to rev the other.
  enum AttributeType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0
    case float // = 1
    case int // = 2
    case string // = 3
    case tensor // = 4
    case graph // = 5
    case floats // = 6
    case ints // = 7
    case strings // = 8
    case tensors // = 9
    case graphs // = 10
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .int
      case 3: self = .string
      case 4: self = .tensor
      case 5: self = .graph
      case 6: self = .floats
      case 7: self = .ints
      case 8: self = .strings
      case 9: self = .tensors
      case 10: self = .graphs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .int: return 2
      case .string: return 3
      case .tensor: return 4
      case .graph: return 5
      case .floats: return 6
      case .ints: return 7
      case .strings: return 8
      case .tensors: return 9
      case .graphs: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Onnx_AttributeProto.AttributeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_AttributeProto.AttributeType] = [
    .undefined,
    .float,
    .int,
    .string,
    .tensor,
    .graph,
    .floats,
    .ints,
    .strings,
    .tensors,
    .graphs,
  ]
}

#endif  // swift(>=4.2)

/// Defines information on value, including the name, the type, and
/// the shape of the value.
struct Onnx_ValueInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field MUST be present in this version of the IR.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// This field MUST be present in this version of the IR.
  var type: Onnx_TypeProto {
    get {return _storage._type ?? Onnx_TypeProto()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// A human-readable documentation for this value. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Nodes
///
/// Computation graphs are made up of a DAG of nodes, which represent what is
/// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
///
/// For example, it can be a node of type "Conv" that takes in an image, a filter 
/// tensor and a bias tensor, and produces the convolved output.
struct Onnx_NodeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// namespace Value
  var input: [String] = []

  /// namespace Value
  var output: [String] = []

  /// An optional identifier for this node in a graph.
  /// This field MAY be absent in ths version of the IR.
  var name: String = String()

  /// The symbolic identifier of the Operator to execute.
  var opType: String = String()

  /// The domain of the OperatorSet that specifies the operator named by op_type.
  var domain: String = String()

  /// Additional named attributes.
  var attribute: [Onnx_AttributeProto] = []

  /// A human-readable documentation for this node. Markdown is allowed.
  var docString: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Models
///
/// ModelProto is a top-level file/container format for bundling a ML model and
/// associating its computation graph with metadata.
///
/// The semantics of the model are described by the associated GraphProto.
struct Onnx_ModelProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the IR this model targets. See Version enum above.
  /// This field MUST be present.
  var irVersion: Int64 {
    get {return _storage._irVersion}
    set {_uniqueStorage()._irVersion = newValue}
  }

  /// The OperatorSets this model relies on.
  /// All ModelProtos MUST have at least one entry that
  /// specifies which version of the ONNX OperatorSet is
  /// being imported.
  ///
  /// All nodes in the ModelProto's graph will bind against the operator
  /// with the same-domain/same-op_type operator with the HIGHEST version
  /// in the referenced operator sets.
  var opsetImport: [Onnx_OperatorSetIdProto] {
    get {return _storage._opsetImport}
    set {_uniqueStorage()._opsetImport = newValue}
  }

  /// The name of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  var producerName: String {
    get {return _storage._producerName}
    set {_uniqueStorage()._producerName = newValue}
  }

  /// The version of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  var producerVersion: String {
    get {return _storage._producerVersion}
    set {_uniqueStorage()._producerVersion = newValue}
  }

  /// Domain name of the model.
  /// We use reverse domain names as name space indicators. For example:
  /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
  ///
  /// Together with `model_version` and GraphProto.name, this forms the unique identity of
  /// the graph.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// The version of the graph encoded. See Version enum below.
  var modelVersion: Int64 {
    get {return _storage._modelVersion}
    set {_uniqueStorage()._modelVersion = newValue}
  }

  /// A human-readable documentation for this model. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  /// The parameterized graph that is evaluated to execute the model.
  var graph: Onnx_GraphProto {
    get {return _storage._graph ?? Onnx_GraphProto()}
    set {_uniqueStorage()._graph = newValue}
  }
  /// Returns true if `graph` has been explicitly set.
  var hasGraph: Bool {return _storage._graph != nil}
  /// Clears the value of `graph`. Subsequent reads from it will return its default value.
  mutating func clearGraph() {_uniqueStorage()._graph = nil}

  /// Named metadata values; keys should be distinct.
  var metadataProps: [Onnx_StringStringEntryProto] {
    get {return _storage._metadataProps}
    set {_uniqueStorage()._metadataProps = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StringStringEntryProto follows the pattern for cross-proto-version maps.
/// See https://developers.google.com/protocol-buffers/docs/proto3#maps
struct Onnx_StringStringEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Onnx_TensorAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tensorName: String = String()

  /// <key, value> pairs to annotate tensor specified by <tensor_name> above.
  /// The keys used in the mapping below must be pre-defined in ONNX spec.
  /// For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
  /// quantization parameter keys.
  var quantParameterTensorNames: [Onnx_StringStringEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Graphs
///
/// A graph defines the computational logic of a model and is comprised of a parameterized 
/// list of nodes that form a directed acyclic graph based on their inputs and outputs.
/// This is the equivalent of the "network" or "graph" in many deep learning
/// frameworks.
struct Onnx_GraphProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nodes in the graph, sorted topologically.
  var node: [Onnx_NodeProto] = []

  /// The name of the graph.
  var name: String = String()

  /// A list of named tensor values, used to specify constant inputs of the graph.
  /// Each TensorProto entry must have a distinct name (within the list) that
  /// MAY also appear in the input list.
  var initializer: [Onnx_TensorProto] = []

  /// A human-readable documentation for this graph. Markdown is allowed.
  var docString: String = String()

  /// The inputs and outputs of the graph.
  var input: [Onnx_ValueInfoProto] = []

  var output: [Onnx_ValueInfoProto] = []

  /// Information for the values in the graph. The ValueInfoProto.name's
  /// must be distinct. It is optional for a value to appear in value_info list.
  var valueInfo: [Onnx_ValueInfoProto] = []

  /// This field carries information to indicate the mapping among a tensor and its
  /// quantization parameter tensors. For example:
  /// For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
  /// which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
  var quantizationAnnotation: [Onnx_TensorAnnotation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Tensors
///
/// A serialized tensor value.
struct Onnx_TensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shape of the tensor.
  var dims: [Int64] {
    get {return _storage._dims}
    set {_uniqueStorage()._dims = newValue}
  }

  /// The data type of the tensor.
  /// This field MUST have a valid TensorProto.DataType value
  var dataType: Int32 {
    get {return _storage._dataType}
    set {_uniqueStorage()._dataType = newValue}
  }

  var segment: Onnx_TensorProto.Segment {
    get {return _storage._segment ?? Onnx_TensorProto.Segment()}
    set {_uniqueStorage()._segment = newValue}
  }
  /// Returns true if `segment` has been explicitly set.
  var hasSegment: Bool {return _storage._segment != nil}
  /// Clears the value of `segment`. Subsequent reads from it will return its default value.
  mutating func clearSegment() {_uniqueStorage()._segment = nil}

  /// For float and complex64 values
  /// Complex64 tensors are encoded as a single array of floats,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component apparing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
  var floatData: [Float] {
    get {return _storage._floatData}
    set {_uniqueStorage()._floatData = newValue}
  }

  /// For int32, uint8, int8, uint16, int16, bool, and float16 values
  /// float16 values must be bit-wise converted to an uint16_t prior
  /// to writing to the buffer.
  /// When this field is present, the data_type field MUST be
  /// INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
  var int32Data: [Int32] {
    get {return _storage._int32Data}
    set {_uniqueStorage()._int32Data = newValue}
  }

  /// For strings.
  /// Each element of string_data is a UTF-8 encoded Unicode
  /// string. No trailing null, no leading BOM. The protobuf "string"
  /// scalar type is not used to match ML community conventions.
  /// When this field is present, the data_type field MUST be STRING
  var stringData: [Data] {
    get {return _storage._stringData}
    set {_uniqueStorage()._stringData = newValue}
  }

  /// For int64.
  /// When this field is present, the data_type field MUST be INT64
  var int64Data: [Int64] {
    get {return _storage._int64Data}
    set {_uniqueStorage()._int64Data = newValue}
  }

  /// Optionally, a name for the tensor.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A human-readable documentation for this tensor. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  /// Serializations can either use one of the fields above, or use this
  /// raw bytes field. The only exception is the string case, where one is
  /// required to store the content in the repeated bytes string_data field.
  ///
  /// When this raw_data field is used to store tensor value, elements MUST
  /// be stored in as fixed-width, little-endian order.
  /// Floating-point data types MUST be stored in IEEE 754 format.
  /// Complex64 elements must be written as two consecutive FLOAT values, real component first.
  /// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
  /// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
  ///
  /// Note: the advantage of specific field rather than the raw_data field is
  /// that in some cases (e.g. int data), protobuf does a better packing via
  /// variable length storage, and may lead to smaller binary footprint.
  /// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
  var rawData: Data {
    get {return _storage._rawData}
    set {_uniqueStorage()._rawData = newValue}
  }

  /// Data can be stored inside the protobuf file using type-specific fields or raw_data.
  /// Alternatively, raw bytes data can be stored in an external file, using the external_data field.
  /// external_data stores key-value pairs describing data location. Recognized keys are:
  /// - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
  ///                           protobuf model was stored
  /// - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
  ///                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
  /// - "length" (optional) - number of bytes containing data. Integer stored as string.
  /// - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
  var externalData: [Onnx_StringStringEntryProto] {
    get {return _storage._externalData}
    set {_uniqueStorage()._externalData = newValue}
  }

  /// If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
  var dataLocation: Onnx_TensorProto.DataLocation {
    get {return _storage._dataLocation}
    set {_uniqueStorage()._dataLocation = newValue}
  }

  /// For double
  /// Complex128 tensors are encoded as a single array of doubles,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component apparing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
  var doubleData: [Double] {
    get {return _storage._doubleData}
    set {_uniqueStorage()._doubleData = newValue}
  }

  /// For uint64 and uint32 values
  /// When this field is present, the data_type field MUST be
  /// UINT32 or UINT64
  var uint64Data: [UInt64] {
    get {return _storage._uint64Data}
    set {_uniqueStorage()._uint64Data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DataType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0

    /// Basic types.
    case float // = 1

    /// uint8_t
    case uint8 // = 2

    /// int8_t
    case int8 // = 3

    /// uint16_t
    case uint16 // = 4

    /// int16_t
    case int16 // = 5

    /// int32_t
    case int32 // = 6

    /// int64_t
    case int64 // = 7

    /// string
    case string // = 8

    /// bool
    case bool // = 9

    /// IEEE754 half-precision floating-point format (16 bits wide).
    /// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
    case float16 // = 10
    case double // = 11
    case uint32 // = 12
    case uint64 // = 13

    /// complex with float32 real and imaginary components
    case complex64 // = 14

    /// complex with float64 real and imaginary components
    case complex128 // = 15

    /// Non-IEEE floating-point format based on IEEE754 single-precision
    /// floating-point number truncated to 16 bits.
    /// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
    case bfloat16 // = 16
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .uint8
      case 3: self = .int8
      case 4: self = .uint16
      case 5: self = .int16
      case 6: self = .int32
      case 7: self = .int64
      case 8: self = .string
      case 9: self = .bool
      case 10: self = .float16
      case 11: self = .double
      case 12: self = .uint32
      case 13: self = .uint64
      case 14: self = .complex64
      case 15: self = .complex128
      case 16: self = .bfloat16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .uint8: return 2
      case .int8: return 3
      case .uint16: return 4
      case .int16: return 5
      case .int32: return 6
      case .int64: return 7
      case .string: return 8
      case .bool: return 9
      case .float16: return 10
      case .double: return 11
      case .uint32: return 12
      case .uint64: return 13
      case .complex64: return 14
      case .complex128: return 15
      case .bfloat16: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Location of the data for this tensor. MUST be one of:
  /// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
  /// - EXTERNAL - data stored in an external location as described by external_data field.
  enum DataLocation: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case external // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .external: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// For very large tensors, we may want to store them in chunks, in which
  /// case the following fields will specify the segment that is stored in
  /// the current TensorProto.
  struct Segment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var begin: Int64 = 0

    var end: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Onnx_TensorProto.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_TensorProto.DataType] = [
    .undefined,
    .float,
    .uint8,
    .int8,
    .uint16,
    .int16,
    .int32,
    .int64,
    .string,
    .bool,
    .float16,
    .double,
    .uint32,
    .uint64,
    .complex64,
    .complex128,
    .bfloat16,
  ]
}

extension Onnx_TensorProto.DataLocation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_TensorProto.DataLocation] = [
    .default,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// Defines a tensor shape. A dimension can be either an integer value
/// or a symbolic variable. A symbolic variable represents an unknown
/// dimension.
struct Onnx_TensorShapeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dim: [Onnx_TensorShapeProto.Dimension] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Dimension {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Onnx_TensorShapeProto.Dimension.OneOf_Value? = nil

    var dimValue: Int64 {
      get {
        if case .dimValue(let v)? = value {return v}
        return 0
      }
      set {value = .dimValue(newValue)}
    }

    /// namespace Shape
    var dimParam: String {
      get {
        if case .dimParam(let v)? = value {return v}
        return String()
      }
      set {value = .dimParam(newValue)}
    }

    /// Standard denotation can optionally be used to denote tensor
    /// dimensions with standard semantic descriptions to ensure
    /// that operations are applied to the correct axis of a tensor.
    /// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
    /// for pre-defined dimension denotations.
    var denotation: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
      case dimValue(Int64)
      /// namespace Shape
      case dimParam(String)

    #if !swift(>=4.1)
      static func ==(lhs: Onnx_TensorShapeProto.Dimension.OneOf_Value, rhs: Onnx_TensorShapeProto.Dimension.OneOf_Value) -> Bool {
        switch (lhs, rhs) {
        case (.dimValue(let l), .dimValue(let r)): return l == r
        case (.dimParam(let l), .dimParam(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

/// Types
///
/// The standard ONNX data types.
struct Onnx_TypeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The type of a tensor.
  var tensorType: Onnx_TypeProto.Tensor {
    get {
      if case .tensorType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Tensor()
    }
    set {_uniqueStorage()._value = .tensorType(newValue)}
  }

  /// An optional denotation can be used to denote the whole 
  /// type with a standard semantic description as to what is 
  /// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
  /// for pre-defined type denotations.
  var denotation: String {
    get {return _storage._denotation}
    set {_uniqueStorage()._denotation = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    /// The type of a tensor.
    case tensorType(Onnx_TypeProto.Tensor)

  #if !swift(>=4.1)
    static func ==(lhs: Onnx_TypeProto.OneOf_Value, rhs: Onnx_TypeProto.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.tensorType(let l), .tensorType(let r)): return l == r
      }
    }
  #endif
  }

  struct Tensor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST NOT have the value of UNDEFINED
    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    var elemType: Int32 {
      get {return _storage._elemType}
      set {_uniqueStorage()._elemType = newValue}
    }

    var shape: Onnx_TensorShapeProto {
      get {return _storage._shape ?? Onnx_TensorShapeProto()}
      set {_uniqueStorage()._shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    var hasShape: Bool {return _storage._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    mutating func clearShape() {_uniqueStorage()._shape = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Operator Sets
///
/// OperatorSets are uniquely identified by a (domain, opset_version) pair.
struct Onnx_OperatorSetIdProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The domain of the operator set being identified.
  /// The empty string ("") or absence of this field implies the operator
  /// set that is defined as part of the ONNX specification.
  /// This field MUST be present in this version of the IR when referring to any other operator set.
  var domain: String = String()

  /// The version of the operator set being identified.
  /// This field MUST be present in this version of the IR.
  var version: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "onnx"

extension Onnx_Version: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_START_VERSION"),
    1: .same(proto: "IR_VERSION_2017_10_10"),
    2: .same(proto: "IR_VERSION_2017_10_30"),
    3: .same(proto: "IR_VERSION_2017_11_3"),
    4: .same(proto: "IR_VERSION_2019_1_22"),
    5: .same(proto: "IR_VERSION"),
  ]
}

extension Onnx_AttributeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttributeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    21: .standard(proto: "ref_attr_name"),
    13: .standard(proto: "doc_string"),
    20: .same(proto: "type"),
    2: .same(proto: "f"),
    3: .same(proto: "i"),
    4: .same(proto: "s"),
    5: .same(proto: "t"),
    6: .same(proto: "g"),
    7: .same(proto: "floats"),
    8: .same(proto: "ints"),
    9: .same(proto: "strings"),
    10: .same(proto: "tensors"),
    11: .same(proto: "graphs"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _refAttrName: String = String()
    var _docString: String = String()
    var _type: Onnx_AttributeProto.AttributeType = .undefined
    var _f: Float = 0
    var _i: Int64 = 0
    var _s: Data = SwiftProtobuf.Internal.emptyData
    var _t: Onnx_TensorProto? = nil
    var _g: Onnx_GraphProto? = nil
    var _floats: [Float] = []
    var _ints: [Int64] = []
    var _strings: [Data] = []
    var _tensors: [Onnx_TensorProto] = []
    var _graphs: [Onnx_GraphProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _refAttrName = source._refAttrName
      _docString = source._docString
      _type = source._type
      _f = source._f
      _i = source._i
      _s = source._s
      _t = source._t
      _g = source._g
      _floats = source._floats
      _ints = source._ints
      _strings = source._strings
      _tensors = source._tensors
      _graphs = source._graphs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._f)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._i)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._s)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._t)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._g)
        case 7: try decoder.decodeRepeatedFloatField(value: &_storage._floats)
        case 8: try decoder.decodeRepeatedInt64Field(value: &_storage._ints)
        case 9: try decoder.decodeRepeatedBytesField(value: &_storage._strings)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._tensors)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._graphs)
        case 13: try decoder.decodeSingularStringField(value: &_storage._docString)
        case 20: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 21: try decoder.decodeSingularStringField(value: &_storage._refAttrName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._f != 0 {
        try visitor.visitSingularFloatField(value: _storage._f, fieldNumber: 2)
      }
      if _storage._i != 0 {
        try visitor.visitSingularInt64Field(value: _storage._i, fieldNumber: 3)
      }
      if !_storage._s.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._s, fieldNumber: 4)
      }
      if let v = _storage._t {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._g {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._floats.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._floats, fieldNumber: 7)
      }
      if !_storage._ints.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._ints, fieldNumber: 8)
      }
      if !_storage._strings.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._strings, fieldNumber: 9)
      }
      if !_storage._tensors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tensors, fieldNumber: 10)
      }
      if !_storage._graphs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._graphs, fieldNumber: 11)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 13)
      }
      if _storage._type != .undefined {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 20)
      }
      if !_storage._refAttrName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refAttrName, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_AttributeProto, rhs: Onnx_AttributeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._refAttrName != rhs_storage._refAttrName {return false}
        if _storage._docString != rhs_storage._docString {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._f != rhs_storage._f {return false}
        if _storage._i != rhs_storage._i {return false}
        if _storage._s != rhs_storage._s {return false}
        if _storage._t != rhs_storage._t {return false}
        if _storage._g != rhs_storage._g {return false}
        if _storage._floats != rhs_storage._floats {return false}
        if _storage._ints != rhs_storage._ints {return false}
        if _storage._strings != rhs_storage._strings {return false}
        if _storage._tensors != rhs_storage._tensors {return false}
        if _storage._graphs != rhs_storage._graphs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_AttributeProto.AttributeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "INT"),
    3: .same(proto: "STRING"),
    4: .same(proto: "TENSOR"),
    5: .same(proto: "GRAPH"),
    6: .same(proto: "FLOATS"),
    7: .same(proto: "INTS"),
    8: .same(proto: "STRINGS"),
    9: .same(proto: "TENSORS"),
    10: .same(proto: "GRAPHS"),
  ]
}

extension Onnx_ValueInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValueInfoProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "doc_string"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _type: Onnx_TypeProto? = nil
    var _docString: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _docString = source._docString
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._docString)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_ValueInfoProto, rhs: Onnx_ValueInfoProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._docString != rhs_storage._docString {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_NodeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "name"),
    4: .standard(proto: "op_type"),
    7: .same(proto: "domain"),
    5: .same(proto: "attribute"),
    6: .standard(proto: "doc_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.input)
      case 2: try decoder.decodeRepeatedStringField(value: &self.output)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeSingularStringField(value: &self.opType)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.attribute)
      case 6: try decoder.decodeSingularStringField(value: &self.docString)
      case 7: try decoder.decodeSingularStringField(value: &self.domain)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitRepeatedStringField(value: self.input, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedStringField(value: self.output, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.opType.isEmpty {
      try visitor.visitSingularStringField(value: self.opType, fieldNumber: 4)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 6)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_NodeProto, rhs: Onnx_NodeProto) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.name != rhs.name {return false}
    if lhs.opType != rhs.opType {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_ModelProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModelProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ir_version"),
    8: .standard(proto: "opset_import"),
    2: .standard(proto: "producer_name"),
    3: .standard(proto: "producer_version"),
    4: .same(proto: "domain"),
    5: .standard(proto: "model_version"),
    6: .standard(proto: "doc_string"),
    7: .same(proto: "graph"),
    14: .standard(proto: "metadata_props"),
  ]

  fileprivate class _StorageClass {
    var _irVersion: Int64 = 0
    var _opsetImport: [Onnx_OperatorSetIdProto] = []
    var _producerName: String = String()
    var _producerVersion: String = String()
    var _domain: String = String()
    var _modelVersion: Int64 = 0
    var _docString: String = String()
    var _graph: Onnx_GraphProto? = nil
    var _metadataProps: [Onnx_StringStringEntryProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _irVersion = source._irVersion
      _opsetImport = source._opsetImport
      _producerName = source._producerName
      _producerVersion = source._producerVersion
      _domain = source._domain
      _modelVersion = source._modelVersion
      _docString = source._docString
      _graph = source._graph
      _metadataProps = source._metadataProps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._irVersion)
        case 2: try decoder.decodeSingularStringField(value: &_storage._producerName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._producerVersion)
        case 4: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._modelVersion)
        case 6: try decoder.decodeSingularStringField(value: &_storage._docString)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._graph)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._opsetImport)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._metadataProps)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._irVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._irVersion, fieldNumber: 1)
      }
      if !_storage._producerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._producerName, fieldNumber: 2)
      }
      if !_storage._producerVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._producerVersion, fieldNumber: 3)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 4)
      }
      if _storage._modelVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._modelVersion, fieldNumber: 5)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 6)
      }
      if let v = _storage._graph {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._opsetImport.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._opsetImport, fieldNumber: 8)
      }
      if !_storage._metadataProps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metadataProps, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_ModelProto, rhs: Onnx_ModelProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._irVersion != rhs_storage._irVersion {return false}
        if _storage._opsetImport != rhs_storage._opsetImport {return false}
        if _storage._producerName != rhs_storage._producerName {return false}
        if _storage._producerVersion != rhs_storage._producerVersion {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._modelVersion != rhs_storage._modelVersion {return false}
        if _storage._docString != rhs_storage._docString {return false}
        if _storage._graph != rhs_storage._graph {return false}
        if _storage._metadataProps != rhs_storage._metadataProps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_StringStringEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringStringEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_StringStringEntryProto, rhs: Onnx_StringStringEntryProto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_name"),
    2: .standard(proto: "quant_parameter_tensor_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tensorName)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.quantParameterTensorNames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorName, fieldNumber: 1)
    }
    if !self.quantParameterTensorNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantParameterTensorNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorAnnotation, rhs: Onnx_TensorAnnotation) -> Bool {
    if lhs.tensorName != rhs.tensorName {return false}
    if lhs.quantParameterTensorNames != rhs.quantParameterTensorNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_GraphProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "name"),
    5: .same(proto: "initializer"),
    10: .standard(proto: "doc_string"),
    11: .same(proto: "input"),
    12: .same(proto: "output"),
    13: .standard(proto: "value_info"),
    14: .standard(proto: "quantization_annotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.node)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.initializer)
      case 10: try decoder.decodeSingularStringField(value: &self.docString)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.input)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.output)
      case 13: try decoder.decodeRepeatedMessageField(value: &self.valueInfo)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.quantizationAnnotation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.initializer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initializer, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 10)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.input, fieldNumber: 11)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.output, fieldNumber: 12)
    }
    if !self.valueInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valueInfo, fieldNumber: 13)
    }
    if !self.quantizationAnnotation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantizationAnnotation, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_GraphProto, rhs: Onnx_GraphProto) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.name != rhs.name {return false}
    if lhs.initializer != rhs.initializer {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.valueInfo != rhs.valueInfo {return false}
    if lhs.quantizationAnnotation != rhs.quantizationAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dims"),
    2: .standard(proto: "data_type"),
    3: .same(proto: "segment"),
    4: .standard(proto: "float_data"),
    5: .standard(proto: "int32_data"),
    6: .standard(proto: "string_data"),
    7: .standard(proto: "int64_data"),
    8: .same(proto: "name"),
    12: .standard(proto: "doc_string"),
    9: .standard(proto: "raw_data"),
    13: .standard(proto: "external_data"),
    14: .standard(proto: "data_location"),
    10: .standard(proto: "double_data"),
    11: .standard(proto: "uint64_data"),
  ]

  fileprivate class _StorageClass {
    var _dims: [Int64] = []
    var _dataType: Int32 = 0
    var _segment: Onnx_TensorProto.Segment? = nil
    var _floatData: [Float] = []
    var _int32Data: [Int32] = []
    var _stringData: [Data] = []
    var _int64Data: [Int64] = []
    var _name: String = String()
    var _docString: String = String()
    var _rawData: Data = SwiftProtobuf.Internal.emptyData
    var _externalData: [Onnx_StringStringEntryProto] = []
    var _dataLocation: Onnx_TensorProto.DataLocation = .default
    var _doubleData: [Double] = []
    var _uint64Data: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dims = source._dims
      _dataType = source._dataType
      _segment = source._segment
      _floatData = source._floatData
      _int32Data = source._int32Data
      _stringData = source._stringData
      _int64Data = source._int64Data
      _name = source._name
      _docString = source._docString
      _rawData = source._rawData
      _externalData = source._externalData
      _dataLocation = source._dataLocation
      _doubleData = source._doubleData
      _uint64Data = source._uint64Data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedInt64Field(value: &_storage._dims)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._dataType)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._segment)
        case 4: try decoder.decodeRepeatedFloatField(value: &_storage._floatData)
        case 5: try decoder.decodeRepeatedInt32Field(value: &_storage._int32Data)
        case 6: try decoder.decodeRepeatedBytesField(value: &_storage._stringData)
        case 7: try decoder.decodeRepeatedInt64Field(value: &_storage._int64Data)
        case 8: try decoder.decodeSingularStringField(value: &_storage._name)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._rawData)
        case 10: try decoder.decodeRepeatedDoubleField(value: &_storage._doubleData)
        case 11: try decoder.decodeRepeatedUInt64Field(value: &_storage._uint64Data)
        case 12: try decoder.decodeSingularStringField(value: &_storage._docString)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._externalData)
        case 14: try decoder.decodeSingularEnumField(value: &_storage._dataLocation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._dims.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dims, fieldNumber: 1)
      }
      if _storage._dataType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dataType, fieldNumber: 2)
      }
      if let v = _storage._segment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._floatData.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._floatData, fieldNumber: 4)
      }
      if !_storage._int32Data.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._int32Data, fieldNumber: 5)
      }
      if !_storage._stringData.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._stringData, fieldNumber: 6)
      }
      if !_storage._int64Data.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._int64Data, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if !_storage._rawData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rawData, fieldNumber: 9)
      }
      if !_storage._doubleData.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._doubleData, fieldNumber: 10)
      }
      if !_storage._uint64Data.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._uint64Data, fieldNumber: 11)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 12)
      }
      if !_storage._externalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._externalData, fieldNumber: 13)
      }
      if _storage._dataLocation != .default {
        try visitor.visitSingularEnumField(value: _storage._dataLocation, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorProto, rhs: Onnx_TensorProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dims != rhs_storage._dims {return false}
        if _storage._dataType != rhs_storage._dataType {return false}
        if _storage._segment != rhs_storage._segment {return false}
        if _storage._floatData != rhs_storage._floatData {return false}
        if _storage._int32Data != rhs_storage._int32Data {return false}
        if _storage._stringData != rhs_storage._stringData {return false}
        if _storage._int64Data != rhs_storage._int64Data {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._docString != rhs_storage._docString {return false}
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._externalData != rhs_storage._externalData {return false}
        if _storage._dataLocation != rhs_storage._dataLocation {return false}
        if _storage._doubleData != rhs_storage._doubleData {return false}
        if _storage._uint64Data != rhs_storage._uint64Data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto.DataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "UINT8"),
    3: .same(proto: "INT8"),
    4: .same(proto: "UINT16"),
    5: .same(proto: "INT16"),
    6: .same(proto: "INT32"),
    7: .same(proto: "INT64"),
    8: .same(proto: "STRING"),
    9: .same(proto: "BOOL"),
    10: .same(proto: "FLOAT16"),
    11: .same(proto: "DOUBLE"),
    12: .same(proto: "UINT32"),
    13: .same(proto: "UINT64"),
    14: .same(proto: "COMPLEX64"),
    15: .same(proto: "COMPLEX128"),
    16: .same(proto: "BFLOAT16"),
  ]
}

extension Onnx_TensorProto.DataLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "EXTERNAL"),
  ]
}

extension Onnx_TensorProto.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TensorProto.protoMessageName + ".Segment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.begin)
      case 2: try decoder.decodeSingularInt64Field(value: &self.end)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.begin != 0 {
      try visitor.visitSingularInt64Field(value: self.begin, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorProto.Segment, rhs: Onnx_TensorProto.Segment) -> Bool {
    if lhs.begin != rhs.begin {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorShapeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dim"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dim)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dim, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorShapeProto, rhs: Onnx_TensorShapeProto) -> Bool {
    if lhs.dim != rhs.dim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto.Dimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TensorShapeProto.protoMessageName + ".Dimension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dim_value"),
    2: .standard(proto: "dim_param"),
    3: .same(proto: "denotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .dimValue(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .dimParam(v)}
      case 3: try decoder.decodeSingularStringField(value: &self.denotation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .dimValue(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    case .dimParam(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if !self.denotation.isEmpty {
      try visitor.visitSingularStringField(value: self.denotation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorShapeProto.Dimension, rhs: Onnx_TensorShapeProto.Dimension) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.denotation != rhs.denotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_type"),
    6: .same(proto: "denotation"),
  ]

  fileprivate class _StorageClass {
    var _value: Onnx_TypeProto.OneOf_Value?
    var _denotation: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _denotation = source._denotation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Onnx_TypeProto.Tensor?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .tensorType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .tensorType(v)}
        case 6: try decoder.decodeSingularStringField(value: &_storage._denotation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .tensorType(let v)? = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._denotation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._denotation, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto, rhs: Onnx_TypeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._denotation != rhs_storage._denotation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Tensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Tensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
    2: .same(proto: "shape"),
  ]

  fileprivate class _StorageClass {
    var _elemType: Int32 = 0
    var _shape: Onnx_TensorShapeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elemType = source._elemType
      _shape = source._shape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._elemType)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._shape)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._elemType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._elemType, fieldNumber: 1)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.Tensor, rhs: Onnx_TypeProto.Tensor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elemType != rhs_storage._elemType {return false}
        if _storage._shape != rhs_storage._shape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_OperatorSetIdProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperatorSetIdProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.domain)
      case 2: try decoder.decodeSingularInt64Field(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_OperatorSetIdProto, rhs: Onnx_OperatorSetIdProto) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
